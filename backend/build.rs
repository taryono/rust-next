// build.rs
// Letakkan di root project (sejajar Cargo.toml)

use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=src/modules");
    println!("cargo:rerun-if-changed=build.rs");

    let modules_path = Path::new("src/modules");
    let docs_path = Path::new("src/docs");

    // Pastikan src/docs ada
    if !docs_path.exists() {
        fs::create_dir_all(docs_path).expect("Failed to create docs directory");
    }

    let mut modules = Vec::new();

    // Scan semua folder di src/modules/*
    if let Ok(entries) = fs::read_dir(modules_path) {
        for entry in entries.flatten() {
            let path = entry.path();

            // Pastikan directory
            if path.is_dir() {
                let module_name = path.file_name().unwrap().to_string_lossy().to_string();
                let docs_file = path.join("docs.rs");

                // Hanya module yang punya docs.rs
                if docs_file.exists() && docs_file.is_file() {
                    modules.push(module_name);
                }
            }
        }
    }

    modules.sort();

    generate_docs_mod(&modules, docs_path);

    println!(
        "cargo:warning=Generated OpenAPI docs for {} modules",
        modules.len()
    );
}

/// Generate src/docs/mod.rs
fn generate_docs_mod(modules: &[String], docs_path: &Path) {
    let mut content = String::new();

    content.push_str("// Auto-generated by build.rs\n");
    content.push_str("// DO NOT EDIT MANUALLY\n\n");
    content.push_str("#![allow(unused_imports)]\n\n");
    // pub use semua module docs
    // for module in modules {
    //     content.push_str(&format!(
    //         "pub use crate::modules::{}::docs::{}ApiDoc;\n",
    //         module,
    //         to_pascal_case(module)
    //     ));
    // }

    content.push_str("\n");

    // Macro merge OpenAPI
    content.push_str(
        r#"#[macro_export]
        macro_rules! merge_api_docs {
            ($($doc:ty),* $(,)?) => {{
                let mut base_api = utoipa::openapi::OpenApiBuilder::new()
                    .info(
                        utoipa::openapi::InfoBuilder::new()
                            .title("My API")
                            .version("1.0.0")
                            .description(Some("Auto-generated API documentation"))
                            .build()
                    )
                    .build();

                $(
                    let doc = <$doc>::openapi();
                    base_api.paths.paths.extend(doc.paths.paths);

                    if let Some(components) = doc.components {
                        if let Some(base_components) = &mut base_api.components {
                            base_components.schemas.extend(components.schemas);
                        } else {
                            base_api.components = Some(components);
                        }
                    }

                    if let Some(tags) = doc.tags {
                        if let Some(base_tags) = &mut base_api.tags {
                            base_tags.extend(tags);
                        } else {
                            base_api.tags = Some(tags);
                        }
                    }
                )*

                base_api
            }};
        }

        #[macro_export]
        macro_rules! generate_openapi {
            () => {{
                merge_api_docs!(
        "#,
    );

    for module in modules {
        let struct_name = to_pascal_case(module);
        content.push_str(&format!(
            "            crate::modules::{}::docs::{}ApiDoc,\n",
            module, struct_name
        ));
    }

    content.push_str(
        r#"        )
    }};
}
"#,
    );

    let mod_path = docs_path.join("mod.rs");
    let mut file = fs::File::create(mod_path).expect("Failed to create docs/mod.rs");
    file.write_all(content.as_bytes())
        .expect("Failed to write docs/mod.rs");
}

/// snake_case â†’ PascalCase
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
