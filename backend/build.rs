// build.rs
// Letakkan file ini di root project (sejajar dengan Cargo.toml)

use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    // Trigger rebuild jika ada perubahan di controllers
    println!("cargo:rerun-if-changed=src/controllers");

    let controllers_path = Path::new("src/controllers");
    let docs_path = Path::new("src/docs");

    // Buat direktori docs jika belum ada
    if !docs_path.exists() {
        fs::create_dir_all(docs_path).expect("Failed to create docs directory");
    }

    let mut controllers = Vec::new();

    // Scan semua file di folder controllers
    if let Ok(entries) = fs::read_dir(controllers_path) {
        for entry in entries.flatten() {
            let path = entry.path();

            // Hanya ambil file .rs, skip mod.rs
            if path.extension().and_then(|s| s.to_str()) == Some("rs") {
                if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                    if file_stem != "mod" {
                        let controller_name = file_stem.to_string();
                        controllers.push(controller_name);
                    }
                }
            }
        }
    }

    controllers.sort(); // Sort untuk konsistensi

    // Generate mod.rs untuk docs
    generate_docs_mod(&controllers, docs_path);

    // Generate individual docs files (optional, bisa di-comment jika mau manual)
    // generate_docs_files(&controllers, docs_path);

    println!(
        "cargo:warning=Generated docs for {} controllers",
        controllers.len()
    );
}

/// Generate src/docs/mod.rs dengan semua module declarations
fn generate_docs_mod(controllers: &[String], docs_path: &Path) {
    let mut content = String::new();

    content.push_str("// Auto-generated by build.rs\n");
    content.push_str("// DO NOT EDIT MANUALLY\n\n");

    // Module declarations
    for controller in controllers {
        let module_name = controller.replace("_controller", "");
        content.push_str(&format!("pub mod {}_docs;\n", module_name));
    }

    content.push_str("\n");
    // warning: unused import: `utoipa::OpenApi`
    // content.push_str("use utoipa::OpenApi;\n\n");

    // Macro definition
    content.push_str(
        r#"/// Macro untuk auto-merge semua OpenAPI docs
#[macro_export]
macro_rules! merge_api_docs {
    ($($doc:ty),* $(,)?) => {{
        let mut base_api = utoipa::openapi::OpenApiBuilder::new()
            .info(
                utoipa::openapi::InfoBuilder::new()
                    .title("My API")
                    .version("1.0.0")
                    .description(Some("Auto-generated API documentation"))
                    .build()
            )
            .build();

        // Merge semua docs
        $(
            let doc = <$doc>::openapi();
            base_api.paths.paths.extend(doc.paths.paths);
            
            if let Some(components) = doc.components {
                if let Some(base_components) = &mut base_api.components {
                    base_components.schemas.extend(components.schemas);
                } else {
                    base_api.components = Some(components);
                }
            }
            
            // Merge tags
            if let Some(new_tags) = doc.tags {
                if let Some(base_tags) = &mut base_api.tags {
                    base_tags.extend(new_tags);
                } else {
                    base_api.tags = Some(new_tags);
                }
            }
        )*

        // Add security schemes
        if let Some(components) = base_api.components.as_mut() {
            components.add_security_scheme(
                "bearer_auth",
                utoipa::openapi::security::SecurityScheme::Http(
                    utoipa::openapi::security::Http::new(
                        utoipa::openapi::security::HttpAuthScheme::Bearer,
                    ),
                ),
            );
        } else {
            base_api.components = Some(
                utoipa::openapi::ComponentsBuilder::new()
                    .security_scheme(
                        "bearer_auth",
                        utoipa::openapi::security::SecurityScheme::Http(
                            utoipa::openapi::security::Http::new(
                                utoipa::openapi::security::HttpAuthScheme::Bearer,
                            ),
                        ),
                    )
                    .build(),
            );
        }

        base_api
    }};
}

"#,
    );

    // Helper function untuk generate macro call
    content.push_str("/// Generate macro call untuk semua docs\n");
    content.push_str("/// Usage: let openapi = generate_openapi!();\n");
    content.push_str("#[macro_export]\n");
    content.push_str("macro_rules! generate_openapi {\n");
    content.push_str("    () => {{\n");
    content.push_str("        merge_api_docs!(\n");

    for controller in controllers {
        let module_name = controller.replace("_controller", "");
        let struct_name = to_pascal_case(&module_name);
        content.push_str(&format!(
            "            docs::{}_docs::{}ApiDoc,\n",
            module_name, struct_name
        ));
    }

    content.push_str("        )\n");
    content.push_str("    }};\n");
    content.push_str("}\n");

    // Write file
    let mod_path = docs_path.join("mod.rs");
    let mut file = fs::File::create(mod_path).expect("Failed to create docs/mod.rs");
    file.write_all(content.as_bytes())
        .expect("Failed to write docs/mod.rs");
}

/// Generate template untuk individual docs files (optional)
#[allow(dead_code)]
fn generate_docs_files(controllers: &[String], docs_path: &Path) {
    for controller in controllers {
        let module_name = controller.replace("_controller", "");
        let struct_name = to_pascal_case(&module_name);
        let docs_file_path = docs_path.join(format!("{}_docs.rs", module_name));

        // Skip jika file sudah ada (tidak overwrite)
        if docs_file_path.exists() {
            continue;
        }

        let mut content = String::new();
        content.push_str(&format!("// Auto-generated template for {}\n", controller));
        content.push_str("// TODO: Fill in the actual paths and schemas\n\n");
        content.push_str("use utoipa::OpenApi;\n");
        content.push_str("use crate::{controllers, models};\n\n");
        content.push_str("#[derive(OpenApi)]\n");
        content.push_str("#[openapi(\n");
        content.push_str("    paths(\n");
        content.push_str(&format!(
            "        // controllers::{}::your_endpoint_here,\n",
            controller
        ));
        content.push_str("    ),\n");
        content.push_str("    components(\n");
        content.push_str("        schemas(\n");
        content.push_str(&format!(
            "            // models::{}::YourModel,\n",
            module_name
        ));
        content.push_str("        )\n");
        content.push_str("    ),\n");
        content.push_str("    tags(\n");
        content.push_str(&format!(
            "        (name = \"{}\", description = \"{} endpoints\")\n",
            module_name, struct_name
        ));
        content.push_str("    )\n");
        content.push_str(")]\n");
        content.push_str(&format!("pub struct {}ApiDoc;\n", struct_name));

        let mut file = fs::File::create(&docs_file_path).expect("Failed to create docs file");
        file.write_all(content.as_bytes())
            .expect("Failed to write docs file");

        println!("cargo:warning=Generated template: {:?}", docs_file_path);
    }
}

/// Convert snake_case to PascalCase
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("auth"), "Auth");
        assert_eq!(to_pascal_case("user"), "User");
        assert_eq!(to_pascal_case("academic_year"), "AcademicYear");
        assert_eq!(to_pascal_case("course_schedule"), "CourseSchedule");
    }
}

// fn main() {
//     let controllers = vec![
//         "auth_controller",
//         "user_controller",
//         "academic_year_controller",
//         "course_schedule_controller",
//     ];
//     generate_docs_files(&controllers, &Path::new("src/docs"));
// }
